=begin
#NIUM Platform

#NIUM Platform

The version of the OpenAPI document: 2023.12.12
Contact: experience@nium.com
Generated by: https://openapi-generator.tech
OpenAPI Generator version: 7.3.0

=end

require 'date'
require 'time'

module NiumClient
  class TransactionResponseDTO
    # This object contains the user defined key-value pairs provided by the client.
    attr_accessor :tags

    # This field contains the country code of the acquirer.
    attr_accessor :acquirer_country_code

    # This field contains the acquiring institution code that identifies the financial institution acting as the acquirer of the transaction.
    attr_accessor :acquiring_institution_code

    # This field contains an authorization amount of the transaction.
    attr_accessor :auth_amount

    # This field contains the authorization code.
    attr_accessor :auth_code

    # This field contains the 3-letter [ISO-4217 currency code](doc:currency-and-country-codes) of the auth currency, the currency in which amount is deducted from wallet.
    attr_accessor :auth_currency_code

    # This field contains the equivalent transaction amount in base currency.
    attr_accessor :billing_amount

    # This field contains the conversion rate of transaction currency to billing currency which is present for all card transactions.
    attr_accessor :billing_conversion_rate

    # This field contains the 3-letter [ISO-4217 currency code](doc:currency-and-country-codes) for the billing currency or base currency
    attr_accessor :billing_currency_code

    # The corrected amount of a transaction in a partial reversal. This is defined by ISO-8583 as a fixed length field with four subfields, but only the first subfield is used. A 12 position field for the corrected, billing amount of a customer's transaction, in the billing currency. The field is right justified, with lead zero fill.
    attr_accessor :billing_replacement_amount

    # This flag is used to mark or unmark a transaction as a business transaction.
    attr_accessor :business_transaction

    # This field contains the unique card identifier generated while new/add-on card issuance.
    attr_accessor :card_hash_id

    # This field contains the amount of a card transaction.
    attr_accessor :card_transaction_amount

    # This field refers to a unique identifier, known as customerHashId, assigned to an individual customer who is associated with a corporate customer at the parent level. This identifier serves the purpose of distinguishing and tracking the child-level customer within a given client's program. By utilizing this identifier, it becomes possible to establish and maintain the appropriate linkage between the child customer and their parent corporate customer, ensuring accurate association and management of customer data.
    attr_accessor :child_customer_hash_id

    # Unique client identifier generated and shared before API handshake.
    attr_accessor :client_hash_id

    # This field contains the auto-generated comments with details on the transactions such as reason for transaction decline.
    attr_accessor :comments

    # This field contains the compliance status of the transaction.The possible values are: NULL IN_PROGRESS ACTION_REQUIRED RFI_REQUESTED RFI_RESPONDED COMPLETED ERROR REJECT EXPIRED
    attr_accessor :compliance_status

    # This field contains the date and time of transaction when created in UTC.
    attr_accessor :created_at

    # This field will be deprecated in the future.
    attr_accessor :current_with_holding_balance

    # This field contains the unique customer identifier generated while new customer created.
    attr_accessor :customer_hash_id

    # This field contains the date on which the transaction occurred in yyyy-MM-dd format.
    attr_accessor :date_of_transaction

    # This field contains the flag signifies if the transaction is a debit transaction.
    attr_accessor :debit

    # This field contains an effective authorization amount which includes fees, markup, etc.
    attr_accessor :effective_auth_amount

    # This object will contain different key-value pairs depending upon the type of transaction. Essentially, this object will contain different labels based on the type of transaction. The list will change over time depending on different use-cases. Refer to the [Glossary of Labels](/apis/docs/transaction-response-labels).
    attr_accessor :labels

    # This field contains the local date of the transaction.
    attr_accessor :local_date

    # This field contains the local time of the transaction.
    attr_accessor :local_time

    # This field contains the 16-digit masked card number in format 1234-56xx-xxxx-3456.
    attr_accessor :masked_card_number

    # This field contains the four-digit Merchant Category Code.
    attr_accessor :mcc

    # This field contains the merchant category such as Airlines, Hotels, Shopping, etc.
    attr_accessor :merchant_category

    # This field contains the city name of the merchant.
    attr_accessor :merchant_city

    # This field contains the country of the merchant.
    attr_accessor :merchant_country

    # This field contains the unique merchant identifier.
    attr_accessor :merchant_id

    # This field contains the latitude of the merchant captured during geo-tagging.
    attr_accessor :merchant_latitude

    # This field contains the longitude of the merchant captured during geo-tagging.
    attr_accessor :merchant_longitude

    # This field contains the name of the merchant.
    attr_accessor :merchant_name

    # This field contains the full merchant name and location data as received from network.
    attr_accessor :merchant_name_location

    # This field contains the tagged name of the merchant.
    attr_accessor :merchant_tagged_name

    # This field contains the merchant map zoom index.
    attr_accessor :merchant_zoom_index

    # This field contains the authorization code of the original transaction in case of reversal.
    attr_accessor :original_authorization_code

    # This field contains the provided by an RHA client in response to an authorization.
    attr_accessor :partner_reference_number

    # This field contains the unique payment instrument identifier generated for the linked card.
    attr_accessor :payment_instrument_hash_id

    # This field contains the pos condition code that describes the condition under which the transaction takes place at the point of service. 00 - Normal transaction 01 - Cardholder not present 03 - Merchant suspicious 08 - Mail/telephone order 51 - Account Verification Message(AVM) 55 - ICC Capable Branch ATM 59 - Electronic Commerce 90 - Recurring Payment
    attr_accessor :pos_condition_code

    # This field provides information about the terminal used at the point of service.Type of terminal field values include:0 - Unspecified 2 - Unattended terminal(customer-operated) 4 - Electronic cash register 7 - Telephone device 8 - MCAS device 9 - Mobile acceptance solution(mPOS) Capability of terminal field values include: 0 - Unspecified 1 - Terminal not used 2 - Magnetic stripe read capability 3 - Bar code read capability 4 - OCR read capability 5 - Integrated circuit card read capability 9 - Terminal does not read card data 
    attr_accessor :pos_entry_capability_code

    # This field contains the pos entry code that identifies the actual method used to capture the account number and expiration date, and the PIN capture capability of the terminal.This is a fixed‑length field with three subfields, as follows: 1. Positions 1‑2 - PAN and Date Entry Mode: This is a two‑digit code that identifies the actual method used at the point of service to enter the cardholder account number and card expiry date. 00 - Unknown 01 - Keyed transaction 02 - Magnetic stripe read 05 - Chip was read at the terminal 07 - Contactless 90 - Magnetic stripe read and transmitted unaltered 91 - Contactless - Magnetic stripe data (MSD) transmitted 2. Position 3 - PIN Entry Capability: This is a one‑digit code that identifies the capability of the authorization terminal, if one was used, to capture PINs. This coding does not necessarily mean that a PIN was entered or is included in this message: 0 - Unknown 1 - Terminal can accept PINs 2 - Terminal cannot accept PINs 3 - mPOS terminal can accept software-based PINs (Mastercard only) 3. Position 4 - Unused(filler): This is one digit of filler, which must be zero. 
    attr_accessor :pos_entry_mode

    # This field contains the previous balance in the wallet.
    attr_accessor :previous_balance

    # This field contains the processing code is a 6 character Visa field. Refer to the [link](https://en.wikipedia.org/wiki/ISO_8583#Processing_code) for more details on the processing code.
    attr_accessor :processing_code

    # This field contains the name of the receipt file.
    attr_accessor :receipt_file_name

    # This field contains the receipt type.Expected values are as follows:  image/png image/jpg image/jpeg application/pdf
    attr_accessor :receipt_type

    # This field contains the 12 digit number that is used with other data elements as a key to identify and track all messages related to a given customer transaction.
    attr_accessor :retrieval_reference_number

    # This field is an array that holds RFI details.
    attr_accessor :rfi_details

    # This field contains the transaction Id for an RHA client.
    attr_accessor :rha_transaction_id

    # This field contains the settlement amount of a transaction. This amount is valid only for a settled transaction.
    attr_accessor :settlement_amount

    # This field contains the settlement auth amount of a transaction. This amount is valid only for a settled transaction.
    attr_accessor :settlement_auth_amount

    attr_accessor :settlement_billing_amount

    attr_accessor :settlement_currency

    # This field contains the settlement date in case of a Settled transaction. Otherwise, it is null.
    attr_accessor :settlement_date

    # This field contains the settlement status.This field can take the following values: Unsettled Settled  Released Disputed DisputeClosed Waived
    attr_accessor :settlement_status

    attr_accessor :settlement_transaction_amount

    # This field contains the status. This field can take the following values: Pending: Transaction authorization is awaiting success or failure. Approved: Transaction is successfully authorized. Rejected: Transaction is rejected due to NIUM risk and compliance policies. Declined: Transaction is declined. Reversal: Transaction is reversed. Blocked: Transaction is blocked
    attr_accessor :status

    # This field contains the system trace audit number assigned to uniquely identify a transaction.
    attr_accessor :system_trace_audit_number

    # This field contains the unique terminal ID.
    attr_accessor :terminal_id

    # This field contains the 3-letter [ISO-4217 currency code](doc:currency-and-country-codes) for the transaction currency.
    attr_accessor :transaction_currency_code

    # The corrected amount of a transaction in a partial reversal. This is defined by ISO-8583 as a fixed length field with four subfields, but only the first subfield is used. A 12 position field for the corrected, actual amount of a customer's transaction, in the transaction currency. The field is right justified, with lead zero fill.
    attr_accessor :transaction_replacement_amount

    # This field contains the transaction can be one of the complete list of transactions mentioned in [Transaction Types](doc:transactions#transaction-types).
    attr_accessor :transaction_type

    # This field contains the date and time when the transaction was last updated in UTC.
    attr_accessor :updated_at

    # This field contains the unique wallet identifier generated while new wallet created.
    attr_accessor :wallet_hash_id

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'tags' => :'tags',
        :'acquirer_country_code' => :'acquirerCountryCode',
        :'acquiring_institution_code' => :'acquiringInstitutionCode',
        :'auth_amount' => :'authAmount',
        :'auth_code' => :'authCode',
        :'auth_currency_code' => :'authCurrencyCode',
        :'billing_amount' => :'billingAmount',
        :'billing_conversion_rate' => :'billingConversionRate',
        :'billing_currency_code' => :'billingCurrencyCode',
        :'billing_replacement_amount' => :'billingReplacementAmount',
        :'business_transaction' => :'businessTransaction',
        :'card_hash_id' => :'cardHashID',
        :'card_transaction_amount' => :'cardTransactionAmount',
        :'child_customer_hash_id' => :'childCustomerHashId',
        :'client_hash_id' => :'clientHashId',
        :'comments' => :'comments',
        :'compliance_status' => :'complianceStatus',
        :'created_at' => :'createdAt',
        :'current_with_holding_balance' => :'currentWithHoldingBalance',
        :'customer_hash_id' => :'customerHashId',
        :'date_of_transaction' => :'dateOfTransaction',
        :'debit' => :'debit',
        :'effective_auth_amount' => :'effectiveAuthAmount',
        :'labels' => :'labels',
        :'local_date' => :'localDate',
        :'local_time' => :'localTime',
        :'masked_card_number' => :'maskedCardNumber',
        :'mcc' => :'mcc',
        :'merchant_category' => :'merchantCategory',
        :'merchant_city' => :'merchantCity',
        :'merchant_country' => :'merchantCountry',
        :'merchant_id' => :'merchantID',
        :'merchant_latitude' => :'merchantLatitude',
        :'merchant_longitude' => :'merchantLongitude',
        :'merchant_name' => :'merchantName',
        :'merchant_name_location' => :'merchantNameLocation',
        :'merchant_tagged_name' => :'merchantTaggedName',
        :'merchant_zoom_index' => :'merchantZoomIndex',
        :'original_authorization_code' => :'originalAuthorizationCode',
        :'partner_reference_number' => :'partnerReferenceNumber',
        :'payment_instrument_hash_id' => :'paymentInstrumentHashId',
        :'pos_condition_code' => :'posConditionCode',
        :'pos_entry_capability_code' => :'posEntryCapabilityCode',
        :'pos_entry_mode' => :'posEntryMode',
        :'previous_balance' => :'previousBalance',
        :'processing_code' => :'processingCode',
        :'receipt_file_name' => :'receiptFileName',
        :'receipt_type' => :'receiptType',
        :'retrieval_reference_number' => :'retrievalReferenceNumber',
        :'rfi_details' => :'rfiDetails',
        :'rha_transaction_id' => :'rhaTransactionId',
        :'settlement_amount' => :'settlementAmount',
        :'settlement_auth_amount' => :'settlementAuthAmount',
        :'settlement_billing_amount' => :'settlementBillingAmount',
        :'settlement_currency' => :'settlementCurrency',
        :'settlement_date' => :'settlementDate',
        :'settlement_status' => :'settlementStatus',
        :'settlement_transaction_amount' => :'settlementTransactionAmount',
        :'status' => :'status',
        :'system_trace_audit_number' => :'systemTraceAuditNumber',
        :'terminal_id' => :'terminalID',
        :'transaction_currency_code' => :'transactionCurrencyCode',
        :'transaction_replacement_amount' => :'transactionReplacementAmount',
        :'transaction_type' => :'transactionType',
        :'updated_at' => :'updatedAt',
        :'wallet_hash_id' => :'walletHashId'
      }
    end

    # Returns all the JSON keys this model knows about
    def self.acceptable_attributes
      attribute_map.values
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'tags' => :'Hash<String, String>',
        :'acquirer_country_code' => :'String',
        :'acquiring_institution_code' => :'String',
        :'auth_amount' => :'Float',
        :'auth_code' => :'String',
        :'auth_currency_code' => :'String',
        :'billing_amount' => :'Float',
        :'billing_conversion_rate' => :'String',
        :'billing_currency_code' => :'String',
        :'billing_replacement_amount' => :'Float',
        :'business_transaction' => :'Boolean',
        :'card_hash_id' => :'String',
        :'card_transaction_amount' => :'Float',
        :'child_customer_hash_id' => :'String',
        :'client_hash_id' => :'String',
        :'comments' => :'String',
        :'compliance_status' => :'String',
        :'created_at' => :'Time',
        :'current_with_holding_balance' => :'Float',
        :'customer_hash_id' => :'String',
        :'date_of_transaction' => :'Time',
        :'debit' => :'Boolean',
        :'effective_auth_amount' => :'Float',
        :'labels' => :'Hash<String, String>',
        :'local_date' => :'String',
        :'local_time' => :'String',
        :'masked_card_number' => :'String',
        :'mcc' => :'String',
        :'merchant_category' => :'String',
        :'merchant_city' => :'String',
        :'merchant_country' => :'String',
        :'merchant_id' => :'String',
        :'merchant_latitude' => :'String',
        :'merchant_longitude' => :'String',
        :'merchant_name' => :'String',
        :'merchant_name_location' => :'String',
        :'merchant_tagged_name' => :'String',
        :'merchant_zoom_index' => :'String',
        :'original_authorization_code' => :'String',
        :'partner_reference_number' => :'String',
        :'payment_instrument_hash_id' => :'String',
        :'pos_condition_code' => :'String',
        :'pos_entry_capability_code' => :'String',
        :'pos_entry_mode' => :'String',
        :'previous_balance' => :'Float',
        :'processing_code' => :'String',
        :'receipt_file_name' => :'String',
        :'receipt_type' => :'String',
        :'retrieval_reference_number' => :'String',
        :'rfi_details' => :'Array<TransactionRfiDetailsResponse>',
        :'rha_transaction_id' => :'String',
        :'settlement_amount' => :'Float',
        :'settlement_auth_amount' => :'Float',
        :'settlement_billing_amount' => :'Float',
        :'settlement_currency' => :'String',
        :'settlement_date' => :'String',
        :'settlement_status' => :'String',
        :'settlement_transaction_amount' => :'Float',
        :'status' => :'String',
        :'system_trace_audit_number' => :'String',
        :'terminal_id' => :'String',
        :'transaction_currency_code' => :'String',
        :'transaction_replacement_amount' => :'Float',
        :'transaction_type' => :'String',
        :'updated_at' => :'Time',
        :'wallet_hash_id' => :'String'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new([
      ])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      if (!attributes.is_a?(Hash))
        fail ArgumentError, "The input argument (attributes) must be a hash in `NiumClient::TransactionResponseDTO` initialize method"
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h|
        if (!self.class.attribute_map.key?(k.to_sym))
          fail ArgumentError, "`#{k}` is not a valid attribute in `NiumClient::TransactionResponseDTO`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
        end
        h[k.to_sym] = v
      }

      if attributes.key?(:'tags')
        if (value = attributes[:'tags']).is_a?(Hash)
          self.tags = value
        end
      end

      if attributes.key?(:'acquirer_country_code')
        self.acquirer_country_code = attributes[:'acquirer_country_code']
      end

      if attributes.key?(:'acquiring_institution_code')
        self.acquiring_institution_code = attributes[:'acquiring_institution_code']
      end

      if attributes.key?(:'auth_amount')
        self.auth_amount = attributes[:'auth_amount']
      end

      if attributes.key?(:'auth_code')
        self.auth_code = attributes[:'auth_code']
      end

      if attributes.key?(:'auth_currency_code')
        self.auth_currency_code = attributes[:'auth_currency_code']
      end

      if attributes.key?(:'billing_amount')
        self.billing_amount = attributes[:'billing_amount']
      end

      if attributes.key?(:'billing_conversion_rate')
        self.billing_conversion_rate = attributes[:'billing_conversion_rate']
      end

      if attributes.key?(:'billing_currency_code')
        self.billing_currency_code = attributes[:'billing_currency_code']
      end

      if attributes.key?(:'billing_replacement_amount')
        self.billing_replacement_amount = attributes[:'billing_replacement_amount']
      end

      if attributes.key?(:'business_transaction')
        self.business_transaction = attributes[:'business_transaction']
      end

      if attributes.key?(:'card_hash_id')
        self.card_hash_id = attributes[:'card_hash_id']
      end

      if attributes.key?(:'card_transaction_amount')
        self.card_transaction_amount = attributes[:'card_transaction_amount']
      end

      if attributes.key?(:'child_customer_hash_id')
        self.child_customer_hash_id = attributes[:'child_customer_hash_id']
      end

      if attributes.key?(:'client_hash_id')
        self.client_hash_id = attributes[:'client_hash_id']
      end

      if attributes.key?(:'comments')
        self.comments = attributes[:'comments']
      end

      if attributes.key?(:'compliance_status')
        self.compliance_status = attributes[:'compliance_status']
      end

      if attributes.key?(:'created_at')
        self.created_at = attributes[:'created_at']
      end

      if attributes.key?(:'current_with_holding_balance')
        self.current_with_holding_balance = attributes[:'current_with_holding_balance']
      end

      if attributes.key?(:'customer_hash_id')
        self.customer_hash_id = attributes[:'customer_hash_id']
      end

      if attributes.key?(:'date_of_transaction')
        self.date_of_transaction = attributes[:'date_of_transaction']
      end

      if attributes.key?(:'debit')
        self.debit = attributes[:'debit']
      end

      if attributes.key?(:'effective_auth_amount')
        self.effective_auth_amount = attributes[:'effective_auth_amount']
      end

      if attributes.key?(:'labels')
        if (value = attributes[:'labels']).is_a?(Hash)
          self.labels = value
        end
      end

      if attributes.key?(:'local_date')
        self.local_date = attributes[:'local_date']
      end

      if attributes.key?(:'local_time')
        self.local_time = attributes[:'local_time']
      end

      if attributes.key?(:'masked_card_number')
        self.masked_card_number = attributes[:'masked_card_number']
      end

      if attributes.key?(:'mcc')
        self.mcc = attributes[:'mcc']
      end

      if attributes.key?(:'merchant_category')
        self.merchant_category = attributes[:'merchant_category']
      end

      if attributes.key?(:'merchant_city')
        self.merchant_city = attributes[:'merchant_city']
      end

      if attributes.key?(:'merchant_country')
        self.merchant_country = attributes[:'merchant_country']
      end

      if attributes.key?(:'merchant_id')
        self.merchant_id = attributes[:'merchant_id']
      end

      if attributes.key?(:'merchant_latitude')
        self.merchant_latitude = attributes[:'merchant_latitude']
      end

      if attributes.key?(:'merchant_longitude')
        self.merchant_longitude = attributes[:'merchant_longitude']
      end

      if attributes.key?(:'merchant_name')
        self.merchant_name = attributes[:'merchant_name']
      end

      if attributes.key?(:'merchant_name_location')
        self.merchant_name_location = attributes[:'merchant_name_location']
      end

      if attributes.key?(:'merchant_tagged_name')
        self.merchant_tagged_name = attributes[:'merchant_tagged_name']
      end

      if attributes.key?(:'merchant_zoom_index')
        self.merchant_zoom_index = attributes[:'merchant_zoom_index']
      end

      if attributes.key?(:'original_authorization_code')
        self.original_authorization_code = attributes[:'original_authorization_code']
      end

      if attributes.key?(:'partner_reference_number')
        self.partner_reference_number = attributes[:'partner_reference_number']
      end

      if attributes.key?(:'payment_instrument_hash_id')
        self.payment_instrument_hash_id = attributes[:'payment_instrument_hash_id']
      end

      if attributes.key?(:'pos_condition_code')
        self.pos_condition_code = attributes[:'pos_condition_code']
      end

      if attributes.key?(:'pos_entry_capability_code')
        self.pos_entry_capability_code = attributes[:'pos_entry_capability_code']
      end

      if attributes.key?(:'pos_entry_mode')
        self.pos_entry_mode = attributes[:'pos_entry_mode']
      end

      if attributes.key?(:'previous_balance')
        self.previous_balance = attributes[:'previous_balance']
      end

      if attributes.key?(:'processing_code')
        self.processing_code = attributes[:'processing_code']
      end

      if attributes.key?(:'receipt_file_name')
        self.receipt_file_name = attributes[:'receipt_file_name']
      end

      if attributes.key?(:'receipt_type')
        self.receipt_type = attributes[:'receipt_type']
      end

      if attributes.key?(:'retrieval_reference_number')
        self.retrieval_reference_number = attributes[:'retrieval_reference_number']
      end

      if attributes.key?(:'rfi_details')
        if (value = attributes[:'rfi_details']).is_a?(Array)
          self.rfi_details = value
        end
      end

      if attributes.key?(:'rha_transaction_id')
        self.rha_transaction_id = attributes[:'rha_transaction_id']
      end

      if attributes.key?(:'settlement_amount')
        self.settlement_amount = attributes[:'settlement_amount']
      end

      if attributes.key?(:'settlement_auth_amount')
        self.settlement_auth_amount = attributes[:'settlement_auth_amount']
      end

      if attributes.key?(:'settlement_billing_amount')
        self.settlement_billing_amount = attributes[:'settlement_billing_amount']
      end

      if attributes.key?(:'settlement_currency')
        self.settlement_currency = attributes[:'settlement_currency']
      end

      if attributes.key?(:'settlement_date')
        self.settlement_date = attributes[:'settlement_date']
      end

      if attributes.key?(:'settlement_status')
        self.settlement_status = attributes[:'settlement_status']
      end

      if attributes.key?(:'settlement_transaction_amount')
        self.settlement_transaction_amount = attributes[:'settlement_transaction_amount']
      end

      if attributes.key?(:'status')
        self.status = attributes[:'status']
      end

      if attributes.key?(:'system_trace_audit_number')
        self.system_trace_audit_number = attributes[:'system_trace_audit_number']
      end

      if attributes.key?(:'terminal_id')
        self.terminal_id = attributes[:'terminal_id']
      end

      if attributes.key?(:'transaction_currency_code')
        self.transaction_currency_code = attributes[:'transaction_currency_code']
      end

      if attributes.key?(:'transaction_replacement_amount')
        self.transaction_replacement_amount = attributes[:'transaction_replacement_amount']
      end

      if attributes.key?(:'transaction_type')
        self.transaction_type = attributes[:'transaction_type']
      end

      if attributes.key?(:'updated_at')
        self.updated_at = attributes[:'updated_at']
      end

      if attributes.key?(:'wallet_hash_id')
        self.wallet_hash_id = attributes[:'wallet_hash_id']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      warn '[DEPRECATED] the `list_invalid_properties` method is obsolete'
      invalid_properties = Array.new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      warn '[DEPRECATED] the `valid?` method is obsolete'
      compliance_status_validator = EnumAttributeValidator.new('String', ["NONE", "IN_PROGRESS", "COMPLETED", "ACTION_REQUIRED", "ERROR", "REJECT", "EXPIRED", "RFI_REQUESTED", "RFI_RESPONDED", "UNKNOWN", "INITIATED", "PENDING", "CLEAR", "CLOSED"])
      return false unless compliance_status_validator.valid?(@compliance_status)
      settlement_status_validator = EnumAttributeValidator.new('String', ["APPROVED", "DECLINED", "BLOCKED", "SETTLED", "UNSETTLED", "REVERSAL", "RELEASED", "PENDING", "WAIVED", "DISPUTED", "DISPUTE_CLOSED", "IN_PROGRESS", "REJECTED", "RETURNED", "AWAITING_FUNDS", "EXPIRED", "CANCELLED", "SCHEDULED", "NA"])
      return false unless settlement_status_validator.valid?(@settlement_status)
      status_validator = EnumAttributeValidator.new('String', ["APPROVED", "DECLINED", "BLOCKED", "SETTLED", "UNSETTLED", "REVERSAL", "RELEASED", "PENDING", "WAIVED", "DISPUTED", "DISPUTE_CLOSED", "IN_PROGRESS", "REJECTED", "RETURNED", "AWAITING_FUNDS", "EXPIRED", "CANCELLED", "SCHEDULED", "NA"])
      return false unless status_validator.valid?(@status)
      transaction_type_validator = EnumAttributeValidator.new('String', ["Debit", "Reversal", "Original_Credit", "Original_Credit_Reversal", "Balance_Inquiry", "Partial_Reversal", "Reversal_Advice", "Decline_Advice", "Incremental_Auth_Reversal", "Auto_Sweep", "Auto_Sweep_Payout", "Auto_Sweep_Payout_Reversal", "Settlement_Debit", "Settlement_Credit", "Settlement_Reversal", "Settlement_Direct_Reversal", "Settlement_Direct_Debit", "Fee_Debit", "Fee_Reversal", "Fee_Waiver", "Client_Prefund", "Client_Refund", "Wallet_Refund", "Wallet_Credit_Mode_Card", "Wallet_Credit_Mode_Prefund", "Wallet_Credit_Mode_Prefund_Cross_Currency", "Wallet_Credit_Mode_Offline", "Wallet_Credit_Mode_Offline_Cross_Currency", "Wallet_Credit_Mode_Offline_ThirdParty", "Wallet_Credit_Mode_Direct_Debit", "Wallet_Credit_Mode_Direct_Debit_Reversal", "Customer_Wallet_Credit_Fund_Transfer", "Customer_Wallet_Debit_Fund_Transfer", "Wallet_Fund_Transfer", "Client_Fund_Transfer", "Wallet_Hold", "Wallet_Unhold", "Remittance_Debit", "Remittance_Debit_External", "Remittance_Reversal", "Remittance_Client_Auto_Sweep", "Remittance_Client_Auto_Sweep_Reversal", "Remittance_Debit_Prescreening", "Remittance_Debit_External_Prescreening", "Remittance_Bene_Microdeposit", "Remittance_Bene_Microdeposit_Reversal", "Regulatory_Auto_Sweep", "Regulatory_Block", "Regulatory_Block_Release", "Regulatory_Debit", "Regulatory_Debit_Reversal", "Transfer_Local", "Transfer_Local_Reversal", "Cashback_Credit", "Cashback_Credit_Client", "Chargeback_Credit", "Customer_Wallet_Debit_Intra_Region", "Customer_Wallet_Credit_Intra_Region", "Customer_Wallet_Debit_Cross_Region", "Customer_Wallet_Credit_Cross_Region", "Direct_Debit_Payout", "Direct_Debit_Payout_Reversal", "Invoicing_Debit", "NA"])
      return false unless transaction_type_validator.valid?(@transaction_type)
      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] compliance_status Object to be assigned
    def compliance_status=(compliance_status)
      validator = EnumAttributeValidator.new('String', ["NONE", "IN_PROGRESS", "COMPLETED", "ACTION_REQUIRED", "ERROR", "REJECT", "EXPIRED", "RFI_REQUESTED", "RFI_RESPONDED", "UNKNOWN", "INITIATED", "PENDING", "CLEAR", "CLOSED"])
      unless validator.valid?(compliance_status)
        fail ArgumentError, "invalid value for \"compliance_status\", must be one of #{validator.allowable_values}."
      end
      @compliance_status = compliance_status
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] settlement_status Object to be assigned
    def settlement_status=(settlement_status)
      validator = EnumAttributeValidator.new('String', ["APPROVED", "DECLINED", "BLOCKED", "SETTLED", "UNSETTLED", "REVERSAL", "RELEASED", "PENDING", "WAIVED", "DISPUTED", "DISPUTE_CLOSED", "IN_PROGRESS", "REJECTED", "RETURNED", "AWAITING_FUNDS", "EXPIRED", "CANCELLED", "SCHEDULED", "NA"])
      unless validator.valid?(settlement_status)
        fail ArgumentError, "invalid value for \"settlement_status\", must be one of #{validator.allowable_values}."
      end
      @settlement_status = settlement_status
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] status Object to be assigned
    def status=(status)
      validator = EnumAttributeValidator.new('String', ["APPROVED", "DECLINED", "BLOCKED", "SETTLED", "UNSETTLED", "REVERSAL", "RELEASED", "PENDING", "WAIVED", "DISPUTED", "DISPUTE_CLOSED", "IN_PROGRESS", "REJECTED", "RETURNED", "AWAITING_FUNDS", "EXPIRED", "CANCELLED", "SCHEDULED", "NA"])
      unless validator.valid?(status)
        fail ArgumentError, "invalid value for \"status\", must be one of #{validator.allowable_values}."
      end
      @status = status
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] transaction_type Object to be assigned
    def transaction_type=(transaction_type)
      validator = EnumAttributeValidator.new('String', ["Debit", "Reversal", "Original_Credit", "Original_Credit_Reversal", "Balance_Inquiry", "Partial_Reversal", "Reversal_Advice", "Decline_Advice", "Incremental_Auth_Reversal", "Auto_Sweep", "Auto_Sweep_Payout", "Auto_Sweep_Payout_Reversal", "Settlement_Debit", "Settlement_Credit", "Settlement_Reversal", "Settlement_Direct_Reversal", "Settlement_Direct_Debit", "Fee_Debit", "Fee_Reversal", "Fee_Waiver", "Client_Prefund", "Client_Refund", "Wallet_Refund", "Wallet_Credit_Mode_Card", "Wallet_Credit_Mode_Prefund", "Wallet_Credit_Mode_Prefund_Cross_Currency", "Wallet_Credit_Mode_Offline", "Wallet_Credit_Mode_Offline_Cross_Currency", "Wallet_Credit_Mode_Offline_ThirdParty", "Wallet_Credit_Mode_Direct_Debit", "Wallet_Credit_Mode_Direct_Debit_Reversal", "Customer_Wallet_Credit_Fund_Transfer", "Customer_Wallet_Debit_Fund_Transfer", "Wallet_Fund_Transfer", "Client_Fund_Transfer", "Wallet_Hold", "Wallet_Unhold", "Remittance_Debit", "Remittance_Debit_External", "Remittance_Reversal", "Remittance_Client_Auto_Sweep", "Remittance_Client_Auto_Sweep_Reversal", "Remittance_Debit_Prescreening", "Remittance_Debit_External_Prescreening", "Remittance_Bene_Microdeposit", "Remittance_Bene_Microdeposit_Reversal", "Regulatory_Auto_Sweep", "Regulatory_Block", "Regulatory_Block_Release", "Regulatory_Debit", "Regulatory_Debit_Reversal", "Transfer_Local", "Transfer_Local_Reversal", "Cashback_Credit", "Cashback_Credit_Client", "Chargeback_Credit", "Customer_Wallet_Debit_Intra_Region", "Customer_Wallet_Credit_Intra_Region", "Customer_Wallet_Debit_Cross_Region", "Customer_Wallet_Credit_Cross_Region", "Direct_Debit_Payout", "Direct_Debit_Payout_Reversal", "Invoicing_Debit", "NA"])
      unless validator.valid?(transaction_type)
        fail ArgumentError, "invalid value for \"transaction_type\", must be one of #{validator.allowable_values}."
      end
      @transaction_type = transaction_type
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          tags == o.tags &&
          acquirer_country_code == o.acquirer_country_code &&
          acquiring_institution_code == o.acquiring_institution_code &&
          auth_amount == o.auth_amount &&
          auth_code == o.auth_code &&
          auth_currency_code == o.auth_currency_code &&
          billing_amount == o.billing_amount &&
          billing_conversion_rate == o.billing_conversion_rate &&
          billing_currency_code == o.billing_currency_code &&
          billing_replacement_amount == o.billing_replacement_amount &&
          business_transaction == o.business_transaction &&
          card_hash_id == o.card_hash_id &&
          card_transaction_amount == o.card_transaction_amount &&
          child_customer_hash_id == o.child_customer_hash_id &&
          client_hash_id == o.client_hash_id &&
          comments == o.comments &&
          compliance_status == o.compliance_status &&
          created_at == o.created_at &&
          current_with_holding_balance == o.current_with_holding_balance &&
          customer_hash_id == o.customer_hash_id &&
          date_of_transaction == o.date_of_transaction &&
          debit == o.debit &&
          effective_auth_amount == o.effective_auth_amount &&
          labels == o.labels &&
          local_date == o.local_date &&
          local_time == o.local_time &&
          masked_card_number == o.masked_card_number &&
          mcc == o.mcc &&
          merchant_category == o.merchant_category &&
          merchant_city == o.merchant_city &&
          merchant_country == o.merchant_country &&
          merchant_id == o.merchant_id &&
          merchant_latitude == o.merchant_latitude &&
          merchant_longitude == o.merchant_longitude &&
          merchant_name == o.merchant_name &&
          merchant_name_location == o.merchant_name_location &&
          merchant_tagged_name == o.merchant_tagged_name &&
          merchant_zoom_index == o.merchant_zoom_index &&
          original_authorization_code == o.original_authorization_code &&
          partner_reference_number == o.partner_reference_number &&
          payment_instrument_hash_id == o.payment_instrument_hash_id &&
          pos_condition_code == o.pos_condition_code &&
          pos_entry_capability_code == o.pos_entry_capability_code &&
          pos_entry_mode == o.pos_entry_mode &&
          previous_balance == o.previous_balance &&
          processing_code == o.processing_code &&
          receipt_file_name == o.receipt_file_name &&
          receipt_type == o.receipt_type &&
          retrieval_reference_number == o.retrieval_reference_number &&
          rfi_details == o.rfi_details &&
          rha_transaction_id == o.rha_transaction_id &&
          settlement_amount == o.settlement_amount &&
          settlement_auth_amount == o.settlement_auth_amount &&
          settlement_billing_amount == o.settlement_billing_amount &&
          settlement_currency == o.settlement_currency &&
          settlement_date == o.settlement_date &&
          settlement_status == o.settlement_status &&
          settlement_transaction_amount == o.settlement_transaction_amount &&
          status == o.status &&
          system_trace_audit_number == o.system_trace_audit_number &&
          terminal_id == o.terminal_id &&
          transaction_currency_code == o.transaction_currency_code &&
          transaction_replacement_amount == o.transaction_replacement_amount &&
          transaction_type == o.transaction_type &&
          updated_at == o.updated_at &&
          wallet_hash_id == o.wallet_hash_id
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [tags, acquirer_country_code, acquiring_institution_code, auth_amount, auth_code, auth_currency_code, billing_amount, billing_conversion_rate, billing_currency_code, billing_replacement_amount, business_transaction, card_hash_id, card_transaction_amount, child_customer_hash_id, client_hash_id, comments, compliance_status, created_at, current_with_holding_balance, customer_hash_id, date_of_transaction, debit, effective_auth_amount, labels, local_date, local_time, masked_card_number, mcc, merchant_category, merchant_city, merchant_country, merchant_id, merchant_latitude, merchant_longitude, merchant_name, merchant_name_location, merchant_tagged_name, merchant_zoom_index, original_authorization_code, partner_reference_number, payment_instrument_hash_id, pos_condition_code, pos_entry_capability_code, pos_entry_mode, previous_balance, processing_code, receipt_file_name, receipt_type, retrieval_reference_number, rfi_details, rha_transaction_id, settlement_amount, settlement_auth_amount, settlement_billing_amount, settlement_currency, settlement_date, settlement_status, settlement_transaction_amount, status, system_trace_audit_number, terminal_id, transaction_currency_code, transaction_replacement_amount, transaction_type, updated_at, wallet_hash_id].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      attributes = attributes.transform_keys(&:to_sym)
      transformed_hash = {}
      openapi_types.each_pair do |key, type|
        if attributes.key?(attribute_map[key]) && attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = nil
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[attribute_map[key]].is_a?(Array)
            transformed_hash["#{key}"] = attributes[attribute_map[key]].map { |v| _deserialize($1, v) }
          end
        elsif !attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = _deserialize(type, attributes[attribute_map[key]])
        end
      end
      new(transformed_hash)
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def self._deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = NiumClient.const_get(type)
        klass.respond_to?(:openapi_any_of) || klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
